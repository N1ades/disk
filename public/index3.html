<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸš€ Live File Sharing</title>
    <!-- <script src="buildtree.mjs" type="text/javascript"></script> -->

    <style>
        html,
        body {
            padding: 0;
            margin: 0;

        }

        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .tree {
            list-style: none;
            padding-left: 0;
        }

        .tree li {
            margin: 4px 0;
        }

        .folder,
        .file {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .folder:hover,
        .file:hover {
            background-color: #1f1f1f;
        }

        .toggle {
            cursor: pointer;
            margin-right: 8px;
            font-size: 12px;
            user-select: none;
        }

        .name {
            flex: 1;
            cursor: pointer;
        }

        .meta {
            margin-left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }

        .count {
            margin-left: auto;

            font-size: 12px;
            opacity: 0.7;
        }

        .actions {
            margin-left: 8px;
        }

        .actions button {
            background: none;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            margin-left: 4px;
            font-size: 12px;
            opacity: 0.8;
        }

        .actions button:hover {
            opacity: 1;
        }
    </style>

</head>

<body>

    <!-- <div>status: <span id="status"></span></div> -->
    <input type="file" id="folderInput" style="display: none;" multiple webkitdirectory />
    <input type="file" id="fileInput" style="display: none;" multiple />

    <div id="dropzone"
        style="width: 100%; height: 200px; border: 2px dashed #aaa; display: flex; align-items: center; justify-content: center; cursor: pointer;">
        Drop files here or click to select files
    </div>
    <br>
    <button type="button" id="selectFiles">select files...</button>
    <button type="button" id="selectFolder">select folder...</button>
    <!-- <span> // </span>
    <button type="button" id="reconnect">reconnect</button> -->
    <br>
    <br>
    <!-- <button type="button" id="drop">drop</button> -->
    <!-- <button type="button" id="stop">stop</button> -->

    <ul id="fileTree" class="tree"></ul>


    <script type="module">
        import { renderTree } from "./buildtree.mjs";

        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func(...args), delay);
            };
        };

        class WebsocketAgent {
            constructor(url) {
                this.open = true;
                this.url = url;
                this.eventListeners = {};
                this.connect();
            }

            heartbeat = () => {
                clearTimeout(this.pingTimeout);

                this.pingTimeout = setTimeout(() => {
                    this.ws.close();
                    delete this.ws;
                    console.log('Reconecting websocket');
                    this.connect();
                }, 4000 + 1000);
            }

            connect = () => {
                this.ws = new WebSocket(this.url);
                this.heartbeat();

                this.ws.addEventListener("error", (event) => {
                    this.heartbeat();
                    console.error(event);

                    this.eventListeners["error"]?.forEach((listener) => listener(event));
                });

                this.ws.addEventListener("open", (event) => {
                    console.log("open");
                    this.heartbeat();

                    this.eventListeners["open"]?.forEach((listener) => listener(event));
                });

                this.ws.addEventListener("message", (event) => {
                    if (typeof event.data !== 'string') {
                        console.error('unsupported messageType');
                        return;
                    }

                    if (event.data.length === 0) {
                        this.heartbeat();
                        return;
                    }

                    this.eventListeners["message"]?.forEach((listener) => listener(event));
                });

                this.ws.addEventListener("close", (event) => {
                    console.log('close');
                    if (this.open) {
                        return // wait for reconnect
                    }

                    this.eventListeners["close"]?.forEach((listener) => listener(event));

                });
            }

            addEventListener = (type, listener, options) => {
                // this.eventListeners[type] = listener;
                this.eventListeners[type] ||= [];
                this.eventListeners[type].push(listener);
            }

            send = (data) => {
                this.ws.send(data);
            }

            close = () => {
                clearTimeout(this.pingTimeout);
                this.open = false;
                this.eventListeners = {};
                this.ws.close();
                delete this.ws;

            }

            _close = () => {
                this.ws.close();
            }
        }

        const parseSizeToBytes = sizeStr => {
            const units = {
                b: 1,
                kb: 1024,
                mb: 1024 ** 2,
                gb: 1024 ** 3
            };

            const match = sizeStr.trim().toLowerCase().match(/^([\d.]+)\s*(b|kb|mb|gb)$/);
            if (!match) throw new Error('invalid size format');

            const [, num, unit] = match;
            return Math.round(parseFloat(num) * units[unit]);
        };

        const generateSeededFile = (seed, sizeInBytes, fileName = 'seeded.bin') => {
            const prng = (() => {
                let s = seed >>> 0;
                return () => {
                    s ^= s << 13;
                    s ^= s >>> 17;
                    s ^= s << 5;
                    return s >>> 0;
                };
            })();

            const buffer = new Uint8Array(sizeInBytes);
            for (let i = 0; i < sizeInBytes; i++) {
                buffer[i] = prng() & 0xFF;
            }

            return new File([buffer], fileName, { type: 'application/octet-stream' });
        };


        // Global variables for tracking transfer and speed data:
        let totalBytesSent = 0;

        const ws = new WebsocketAgent(`${location.protocol.includes('s') ? 'wss' : 'ws'}://${location.host}`);
        const MessageType = {
            INIT: 0,
            DATA: 1,
            REQUEST: 2,
            FILES: 3,
        };

        // document.getElementById('stop').addEventListener('click', () => {
        //     ws.close()
        // }, { once: true })
        // document.getElementById('reconnect').addEventListener('click', () => {
        //     ws._close()
        // })

        class FileExplorer {
            files = new Map();
            filesInfo = new Map();

            addFile = async (entry) => {
                // console.log('add file', entry);

                const file = entry?.file ? await new Promise((resolve, reject) => {
                    entry?.file(resolve, reject)
                }) : entry;

                const path = entry.fullPath || entry.webkitRelativePath || file.webkitRelativePath || file.fullPath || file.name;

                const meta = {
                    path: 'Shared/' + path.replace(/^\/+/, ''),
                    info: {
                        name: path.split('/').pop(),
                        lastModified: file.lastModified,
                        size: file.size,
                        type: file.type,
                    },
                    file: file,
                }

                const metaHash = JSON.stringify(meta.info)
                if (this.files.has(meta.path)) {
                    this.files.delete(meta.path);
                    this.filesInfo.delete(metaHash)
                }

                const existsFileInfo = this.filesInfo.get(metaHash)
                if (existsFileInfo) {
                    this.files.delete(existsFileInfo.path);
                    this.filesInfo.delete(metaHash)
                }

                this.files.set(meta.path, meta);
                this.filesInfo.set(JSON.stringify(meta.info), meta);
                this.updateList();
            }

            updateList = debounce(async () => {
                renderTree(document.getElementById('fileTree'), this.files);
            }, 100);
        }

        const fileExplorer = new FileExplorer();

        ws.addEventListener('open', () => {
            const jsonPayload = JSON.stringify({
                sessionSecret: ws.sessionSecret
            });
            const encoder = new TextEncoder();
            const jsonBytes = encoder.encode(jsonPayload);
            const buffer = new Uint8Array(8 + jsonBytes.length);

            buffer.set(new Uint8Array(new BigInt64Array([BigInt(MessageType.INIT)]).buffer), 0);
            buffer.set(jsonBytes, 8);
            console.log('send init');

            ws.send(buffer);

            totalBytesSent += buffer.byteLength;
        });


        ws.addEventListener('message', async (event) => {
            if (event.data.length === 0) {
                console.log('received ping');

                return
            }

            console.log(typeof event.data);

            if (typeof event.data === 'string') {
                const data = JSON.parse(event.data);

                if (data.sessionSecret) {
                    ws.sessionSecret = data.sessionSecret;
                }

                if (data.files) {
                    for (const file of data.files) {
                        console.log(`ðŸ“„ ${file.name} - Live`);
                        console.log('downloadLink:', new URL(file.downloadLink, window.location.protocol + '//' + window.location.host).toString());
                    }
                }

                if (data.filename) {
                    const chunk = data;
                    const file = files.find(({ filename }) => filename === chunk.filename);

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const buffer = new Uint8Array(e.target.result);
                        const combined = new Uint8Array(8 + 8 + buffer.byteLength);
                        combined.set(new Uint8Array(new BigInt64Array([BigInt(MessageType.DATA)]).buffer), 0);
                        combined.set(new Uint8Array(new BigInt64Array([BigInt(chunk.chunkId)]).buffer), 8);
                        combined.set(buffer, 16);
                        ws.send(combined);
                        totalBytesSent += combined.byteLength;
                    };
                    const blob = file.slice(chunk.rangeStart, chunk.rangeEnd === -1 ? undefined : chunk.rangeEnd + 1);
                    reader.readAsArrayBuffer(blob);
                }
            } else {
                console.error('unsupported messageType');
            }
        })



        // Drop handler function to get all files
        const getAllFileEntries = async (dataTransferItemList) => {
            let fileEntries = [];
            // Use BFS to traverse entire directory/file structure
            let queue = [];
            // Unfortunately dataTransferItemList is not iterable i.e. no forEach
            for (let i = 0; i < dataTransferItemList.length; i++) {
                // Note webkitGetAsEntry a non-standard feature and may change
                // Usage is necessary for handling directories
                queue.push(dataTransferItemList[i].webkitGetAsEntry());
            }
            while (queue.length > 0) {
                let entry = queue.shift();
                if (entry.isFile) {
                    // const file = await new Promise((resolve, reject) => { entry.file(resolve, reject); });
                    // file.webkitRelativePath = entry.webkitRelativePath;
                    // console.log(file);

                    fileEntries.push(entry);
                } else if (entry.isDirectory) {
                    queue.push(...await readAllDirectoryEntries(entry.createReader()));
                }
            }
            return fileEntries;
        }

        // Get all the entries (files or sub-directories) in a directory 
        // by calling readEntries until it returns empty array
        const readAllDirectoryEntries = async (directoryReader) => {
            let entries = [];
            let readEntries = await readEntriesPromise(directoryReader);
            while (readEntries.length > 0) {
                entries.push(...readEntries);
                readEntries = await readEntriesPromise(directoryReader);
            }
            return entries;
        }

        // Wrap readEntries in a promise to make working with readEntries easier
        // readEntries will return only some of the entries in a directory
        // e.g. Chrome returns at most 100 entries at a time
        const readEntriesPromise = async (directoryReader) => {
            try {
                return await new Promise((resolve, reject) => {
                    directoryReader.readEntries(resolve, reject);
                });
            } catch (err) {
                console.log(err);
            }
        }

        const drop = async (file) => {
            if (!file) return;

            // Animate the title to show the filename
            //console.log(`ðŸ“„ ${file.name} - Live File Sharing`);


            fileExplorer.addFile();
            //files.push()

            // Open WebSocket connection

        };

        document.getElementById('dropzone').addEventListener('click', function () {
            document.getElementById('fileInput').click();
        });

        document.getElementById('selectFiles').addEventListener('click', function () {
            document.getElementById('fileInput').click();
        });
        document.getElementById('selectFolder').addEventListener('click', function () {
            document.getElementById('folderInput').click();
        });

        const change = async function (event) {
            let files = Array.from(event.currentTarget.files);
            try {

                //let items = await getAllFileEntries(event.currentTarget.files);

                // const files = [...event.currentTarget.files];
                // console.log(files);
                for (const file of files) {
                    fileExplorer.addFile(file);
                }
            } finally {
                event.currentTarget.value = null;
            }

        }


        // Handle files selected via the file picker
        document.getElementById('fileInput').addEventListener('change', change);
        document.getElementById('folderInput').addEventListener('change', change);

        // Handle drag over
        document.getElementById('dropzone').addEventListener('dragover', function (event) {
            event.preventDefault();
        });

        // Handle drop
        document.getElementById('dropzone').addEventListener('drop', async function (event) {
            event.preventDefault();
            let files = await getAllFileEntries(event.dataTransfer.items);
            console.log(files.length);
            console.log(files.length);
            let i;
            for (const file of files) {
                i++;
                await fileExplorer.addFile(file);
            }

            console.log('done');

            // elItems.innerHTML = items.length;
            // You can further process dropped items here
        });

        // document.getElementById('drop').addEventListener('click', () => {
        //     drop(generateSeededFile(1337, parseSizeToBytes('111mb'), 'testfile.bin'))
        // })


    </script>
</body>

</html>